# Middleware
MiddlewareGenerally used to intercept requests orResponse。e.g. executecontrollerPre-unified authentication of user identity，如User not logged inJump to the login page when，exampleResponsewill force the use ofheader头。the route defined inuriThe difference between methods is。

## Middleware Onion Model

```
                              
            ┌──────────────────────────────────────────────────────┐
            │                     middleware1                      │ 
            │     ┌──────────────────────────────────────────┐     │
            │     │               middleware2                │     │
            │     │     ┌──────────────────────────────┐     │     │
            │     │     │         middleware3          │     │     │        
            │     │     │     ┌──────────────────┐     │     │     │
            │     │     │     │                  │     │     │     │
 　── request ───────────────────────> controller ─ Response ───────────────────────────> client
            │     │     │     │                  │     │     │     │
            │     │     │     └──────────────────┘     │     │     │
            │     │     │                              │     │     │
            │     │     └──────────────────────────────┘     │     │
            │     │                                          │     │
            │     └──────────────────────────────────────────┘     │
            │                                                      │
            └──────────────────────────────────────────────────────┘
```
The middleware and the controller form a classic onion model, with the middleware resembling a layer of onion skin and the controller being the onion core. If the request shown traverses middleware 1, 2, 3 like an arrow to the controller, the controller returns a response, and then the response in turn traverses the middleware in the order of 3, 2, 1 and finally returns to the client. This means that in each middleware we can get both the request and the response。

## Request Interception
Sometimes we don't want a request to arrivecontroller层，For example, we are in a certainAuthentication Middlewarefound that the current user is not logged in，then we can directly intercept the request and return a loginResponse。Then the process is similar to the following

```
                              
            ┌───────────────────────────────────────────────────────┐
            │                     middleware1                       │ 
            │     ┌───────────────────────────────────────────┐     │
            │     │          　 　 Authentication Middleware                │     │
            │     │      ┌──────────────────────────────┐     │     │
            │     │      │         middleware3          │     │     │        
            │     │      │     ┌──────────────────┐     │     │     │
            │     │      │     │                  │     │     │     │
 　── Request ───────────┐ │ │ Controller      │     │     │     │
            │     │ Response　│     │                  │     │     │     │
   <─────────────────┘   │     └──────────────────┘     │     │     │
            │     │      │                              │     │     │
            │     │      └──────────────────────────────┘     │     │
            │     │                                           │     │
            │     └───────────────────────────────────────────┘     │
            │                                                       │
            └───────────────────────────────────────────────────────┘
```

As shown in the figure the request reaches the authentication middleware and generates a login response, which traverses from the authentication middleware back to middleware 1 and then returns to the browser。

## Middleware Interface
Middlewaremust implement`Webman\MiddlewareInterface`interface。
```php
interface MiddlewareInterface
{
    /**
     * Process an incoming server request.
     *
     * Processes an incoming server request in order to produce a response.
     * If unable to produce the response itself, it may delegate to the provided
     * request handler to do so.
     */
    public function process(Request $request, callable $handler): Response;
}
```
which means it must be implemented`process`Method，`process`The method must return a`support\Response`object，Default this object by`$handler($request)`generate(The request will continue to traverse to the onion core)，or use the command`response()` `json()` `xml()` `redirect()`etc. generated by helper functionsResponse(Request to stop the continuation of the traversal to the onion core)。

## Get request and response in middleware
In the middleware we can get the request and the response after executing the controller, so the middleware is internally divided into three parts。
1. The request traversal phase, which is the phase before the request is processed  
2. Controller processing request phase, also known as request processing phase  
3. The response wear-out phase, which is the phase after the request is processed  

The three phases are reflected in the middleware as follows
```php
<?php
namespace app\middleware;

use Webman\MiddlewareInterface;
use Webman\Http\Response;
use Webman\Http\Request;

class Test implements MiddlewareInterface
{
    public function process(Request $request, callable $handler) : Response
    {
        echo 'This is the request traversal phase, which is the phase before the request is processed';
        
        $response = $handler($request); // Continue traversing to the onion core until the execution controller gets a response
        
        echo 'This is the response wear-out phase, which is after the request is processed';
        
        return $response;
    }
}
```
 
## Example: Authentication Middleware
Create the file `app/middleware/AuthCheckTest.php` (if the directory does not exist, please create it yourself) as follows：
```php
<?php
namespace app\middleware;

use Webman\MiddlewareInterface;
use Webman\Http\Response;
use Webman\Http\Request;

class AuthCheckTest implements MiddlewareInterface
{
    public function process(Request $request, callable $handler) : Response
    {
        $session = $request->session();
        // User not logged in
        if (!$session->get('userinfo')) {
            // Intercept the request and return a redirect response with the request to stop traversing towards the onion core
            return redirect('/user/login');
        }
        // The request continues to traverse towards the onion core
        return $handler($request);
    }
}
```

Add the global middleware to `config/middleware.php` as follows：
```php
return [
    // Global Middleware
    '' => [
        // ... Omit other middleware here
        app\middleware\AuthCheckTest::class,
    ]
];
```

With authentication middleware, we can concentrate on writing business code at the controller level and not worry about whether the user is logged in or not。

## Example: Cross-domain request middleware
Create the file `app/middleware/AccessControlTest.php` (if the directory does not exist, please create it yourself) as follows：
```php
<?php
namespace app\middleware;

use Webman\MiddlewareInterface;
use Webman\Http\Response;
use Webman\Http\Request;

class AccessControlTest implements MiddlewareInterface
{
    public function process(Request $request, callable $handler) : Response
    {
        // Return an empty response if opitons are requested, otherwise continue traversing to the onion core and get a response
        $response = $request->method() == 'OPTIONS' ? response('') : $handler($request);
        
        // Add cross-domain related http headers to the response
        $response->withHeaders([
            'Access-Control-Allow-Credentials' => 'true',
            'Access-Control-Allow-Origin' => $request->header('origin', '*'),
            'Access-Control-Allow-Methods' => $request->header('access-control-request-method', '*'),
            'Access-Control-Allow-Headers' => $request->header('access-control-request-headers', '*'),
        ]);
        
        return $response;
    }
}
```

> **hint**
> cross-domain may be generatedOPTIONSrequest，we don't wantOPTIONSSo we have forcontroller，in the code belowOPTIONSThe request returns an empty one directlyResponse(`response('')`)achieveRequest Interception。
> return value of the methodrequiredSet route，Please use`Route::any(..)` or `Route::add(['POST', 'OPTIONS'], ..)`set。

Add the global middleware to `config/middleware.php` as follows：
```php
return [
    // Global Middleware
    '' => [
        // ... Omit other middleware here
        app\middleware\AccessControlTest::class,
    ]
];
```

> **Note**
> ifajaxThe access address is thenheader头，required在Middleware里 `Access-Control-Allow-Headers` field join this customheader头，Otherwise it will report` Request header field XXXX is not allowed by Access-Control-Allow-Headers in preflight response.`


## Description
  
 - MiddlewareDivideGlobal Middleware、Application middleware (application middleware is only available in multi-application mode)，See[more applications](multiapp.md))、Routing middleware
 - Middleware for a single controller is not currently supported (but controller-like middleware functionality can be implemented in middleware by determining `$request->controller`)
 - Middleware configuration file location in `config/middleware.php`
 - Global middleware configuration under key `''`
 - The application middleware is configured under the specific application name, for example

```php
return [
    // Global Middleware
    '' => [
        app\middleware\AuthCheckTest::class,
        app\middleware\AccessControlTest::class,
    ],
    // apiApplication middleware (application middleware is only available in multi-application mode))
    'api' => [
        app\middleware\ApiOnly::class,
    ]
];
```

## Routing middleware

We can set up middleware for a particular route or group of routes。
For example, add the following configuration to `config/route.php`：
```php
<?php
use support\Request;
use Webman\Route;

Route::any('/admin', [app\admin\controller\IndexController::class, 'index'])->middleware([
    app\middleware\MiddlewareA::class,
    app\middleware\MiddlewareB::class,
]);

Route::group('/blog', function () {
   Route::any('/create', function () {return response('create');});
   Route::any('/edit', function () {return response('edit');});
   Route::any('/view/{id}', function ($r, $id) {response("view $id");});
})->middleware([
    app\middleware\MiddlewareA::class,
    app\middleware\MiddlewareB::class,
]);
```

## Middleware constructor pass-through

> **Note**
> Required for this featurewebman-framework >= 1.4.8

1.4.8After the version, the configuration file supports instantiating middleware or anonymous functions directly, which makes it easy to pass parameters to the middleware via the constructor。
You can also do this in `config/middleware.php` for example
```
return [
    // Global Middleware
    '' => [
        new app\middleware\AuthCheckTest($param1, $param2, ...),
        function(){
            return new app\middleware\AccessControlTest($param1, $param2, ...);
        },
    ],
    // apiApplication middleware (application middleware is only available in multi-application mode))
    'api' => [
        app\middleware\ApiOnly::class,
    ]
];
```

Similarly routing middleware can pass arguments to the middleware via the constructor, for example in `config/route.php`
```
Route::any('/admin', [app\admin\controller\IndexController::class, 'index'])->middleware([
    new app\middleware\MiddlewareA($param1, $param2, ...),
    function(){
        return new app\middleware\MiddlewareB($param1, $param2, ...);
    },
]);
```

## Middleware Execution Order
 - The middleware execution order is `global middleware`->`application middleware`->`routing middleware`。
 - If there is more than one global middleware, execute the middleware in the order it is actually configured (same for application middleware and routing middleware))。
 - 404Requests do not trigger any middleware, including global middleware

## Routing to middleware for passing parameters(route->setParams)

**Routing configuration `config/route.php`**
```php
<?php
use support\Request;
use Webman\Route;

Route::any('/test', [app\controller\IndexController::class, 'index'])->setParams(['some_key' =>'some value']);
```

**middleware (assume global middleware)**
```php
<?php
namespace app\middleware;

use Webman\MiddlewareInterface;
use Webman\Http\Response;
use Webman\Http\Request;

class Hello implements MiddlewareInterface
{
    public function process(Request $request, callable $handler) : Response
    {
        // The default route $request->route is null, so you need to determine if $request->route is null
        if ($route = $request->route) {
            $value = $route->param('some_key');
            var_export($value);
        }
        return $handler($request);
    }
}
```

 
## Middleware Passes Parameters to Controller

Sometimes the controller needs to use the data generated in the middleware, then we can pass the controller by adding properties to the `$request` object. For example ：

**Middleware**
```php
<?php
namespace app\middleware;

use Webman\MiddlewareInterface;
use Webman\Http\Response;
use Webman\Http\Request;

class Hello implements MiddlewareInterface
{
    public function process(Request $request, callable $handler) : Response
    {
        $request->data = 'some value';
        return $handler($request);
    }
}
```

**controller：**
```php
<?php
namespace app\controller;

use support\Request;

class FooController
{
    public function index(Request $request)
    {
        return response($request->data);
    }
}
```

## The middleware gets the current request routing information
> **Note**
> required webman-framework >= 1.3.2

We can use `$request->route` to get the routing object and get the corresponding information by calling the corresponding method。

**Routing configuration**
```php
<?php
use support\Request;
use Webman\Route;

Route::any('/user/{uid}', [app\controller\UserController::class, 'view']);
```

**Middleware**
```php
<?php
namespace app\middleware;

use Webman\MiddlewareInterface;
use Webman\Http\Response;
use Webman\Http\Request;

class Hello implements MiddlewareInterface
{
    public function process(Request $request, callable $handler) : Response
    {
        $route = $request->route;
        // If the request does not match any route (except the default route), then $request->route is null
        // Assuming a browser accesses the address /user/111, the following message will be printed
        if ($route) {
            var_export($route->getPath());       // /user/{uid}
            var_export($route->getMethods());    // ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD','OPTIONS']
            var_export($route->getName());       // user_view
            var_export($route->getMiddleware()); // []
            var_export($route->getCallback());   // ['app\\controller\\UserController', 'view']
            var_export($route->param());         // ['uid'=>111]
            var_export($route->param('uid'));    // 111 
        }
        return $handler($request);
    }
}
```

> **Note**
> `$route->param()`method needs webman-framework >= 1.3.16


## Middleware get exception
> **Note**
> required webman-framework >= 1.3.15

Exceptions may be generated during business processing, use `$response->exception()` in the middleware to get them。

**Routing configuration**
```php
<?php
use support\Request;
use Webman\Route;

Route::any('/user/{uid}', function (Request $request, $uid) {
    throw new \Exception('exception test');
});
```

**Middleware：**
```php
<?php
namespace app\middleware;

use Webman\MiddlewareInterface;
use Webman\Http\Response;
use Webman\Http\Request;

class Hello implements MiddlewareInterface
{
    public function process(Request $request, callable $handler) : Response
    {
        $response = $handler($request);
        $exception = $response->exception();
        if ($exception) {
            echo $exception->getMessage();
        }
        return $response;
    }
}
```
